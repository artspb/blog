+++ 
draft = false
date = 2021-09-13T16:33:53+02:00
title = "Debugging gopls with GoLand"
description = "In a few simple steps, one can interactively debug gopls with GoLand. This article gives step by step instructions on how to do it."
images = ["/images/debugging-gopls-with-goland/breakpoint-hit.png"]
slug = "debugging-gopls-with-goland"
tags = ["GoLand", "Go", "LSP", "gopls", "Debugger"]
categories = ["Go", "Tools", "Tutorials"]
series = ["GoLand"]
+++

In the previous issue of _learning by observing_, I've described how one can [debug the Go compiler](/posts/debugging-go-compiler-with-goland/). This time, I'd like to share with you how one can debug `gopls` using [GoLand](https://www.jetbrains.com/go/).

`gopls` is a language server protocol implementation for Go. Its [source code](https://github.com/golang/tools/tree/master/gopls) is available on GitHub. While, typically, debugging a program in GoLand is as easy as a couple of clicks, the problem with `gopls` is that _a)_ it's launched by an editor _b)_ at an arbitrary moment in time. This makes it harder to attach a debugger to it. Fortunately, there's a better way called [a daemon](https://github.com/golang/tools/blob/master/gopls/doc/daemon.md). It allows splitting `gopls` into a client and a server. The former works as a proxy while the latter does all the work. What is more important in our case, it's trivial to launch the server right in the IDE.

Let's start with checking out Go [`tools`](https://github.com/golang/tools) and opening [`gopls/main.go`](https://github.com/golang/tools/blob/master/gopls/main.go). Before launching it, we need to add an argument `-listen=:37374` (you can use any other port or even [a Unix socket](https://github.com/golang/tools/blob/master/gopls/doc/daemon.md#managing-the-daemon-manually)) that tells `gopls` to act as a server. In GoLand, one does it by modifying [a run configuration](https://www.jetbrains.com/help/go/run-debug-configuration.html).

![Modify Run Configuration...](/images/debugging-gopls-with-goland/modify-run-configuration.png)

It's enough to update _Program arguments_. The rest is automatically generated by the IDE.

![Run Configuration](/images/debugging-gopls-with-goland/run-configuration.png)

After saving the run configuration with _OK_, we can launch `gopls` by choosing _Debug 'go build golang.org/...'_ instead of _Modify Run Configuration..._ Now, we need to teach an editor to start a client version of `gopls`. The process might look different for different editors. I use [Visual Studio Code](https://code.visualstudio.com/) as the most popular one.

Actually, there's not much to tell here. The Go plugin for VS Code has [a setting](https://github.com/golang/vscode-go/blob/master/docs/settings.md#golanguageserverflags) `go.languageServerFlags` that allows passing arguments to `gopls`. It's enough to add `-remote=:37374` to the list of flags (don't forget to update the port if you've decided to change it for `-listen`). In my case, `.vscode/settings.json` looks pretty much basic.

```json
{
    "go.languageServerFlags": [
        "-remote=:37374"
    ]
}
```

Now, let's add [a breakpoint](https://www.jetbrains.com/help/go/using-breakpoints.html) in GoLand. [`internal/lsp/server_gen.go`](https://github.com/golang/tools/blob/master/internal/lsp/server_gen.go) is an LSP server entry point. For many commands, it's easy enough to start here. The next logical step would be to call a command and see what happens.

![Go to Definition](/images/debugging-gopls-with-goland/go-to-definition.png)

[The official LSP documentation](https://docs.microsoft.com/en-us/visualstudio/extensibility/language-server-protocol) uses _Go to Definition_ as an example. Let's find out how it's implemented for Go.

![Breakpoint Hit](/images/debugging-gopls-with-goland/breakpoint-hit.png)

That's it; we're good to dive in. GoLand hits the breakpoint, so one can [examine](https://www.jetbrains.com/help/go/examining-suspended-program.html) the program's state and control its [execution](https://www.jetbrains.com/help/go/stepping-through-the-program.html) in an interactive manner. All variables have actual values, and we can even change them. The most curious can go further and [evaluate expressions](https://www.jetbrains.com/help/go/examining-suspended-program.html#evaluating-expressions) right inside the running application instance.

P.S. Special thanks go to Hana Kim, who gave me a hint about the `gopls` daemon on [Gophers Slack](https://gophers.slack.com/archives/C2B4L99RS/p1630933343069000). Thank you!